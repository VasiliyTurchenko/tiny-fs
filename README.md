

# **TINY-FS**

Компактная файловая система.

Собственно исходный код файловой системы находится в паре `tiny-fs.c/.h`, файлы `ls.c/.h` содержат код команды **ls**.



### Основные особенности и ограничения.

#### Описание носителя.

Для работы с носителем информации требуется создать индивидуальную структуру для каждого имеющегося носителя:

```c
/* Media decriptor */
typedef struct {
	ErrorStatus (*readFunc)(uint8_t *, uint32_t,
				size_t); /* read function for the media */
	ErrorStatus (*writeFunc)(uint8_t *, uint32_t,
				 size_t); /* write function for the media */
	size_t MediaSize;
	Meida_Mode_t mode;
} Media_Desc_t;
```

Режим доступа може быть:

```c
typedef enum {
	MEDIA_RW,	/* media can be read and written */
	MEDIA_RO	/* read-only media */
} Meida_Mode_t;
```

Все операции с носителем производятся посредством этих двух функций.

Для расчёт контрольных сумм необходимо иметь функцию

```c
uint32_t CRC32(uint8_t * addr_from, size_t len, uint32_t initCRC);
```



#### Настройки на этапе компиляции.

В файле `tiny-fs.h` есть несколько дефайнов, определяющих особенности ФС:

```c
/* определяет максимальную длину имент файла */
#define MAX_FILENAME_LEN 7U

/* сколько элементов может содержать каталог файлов , 1 из них будет зарезервирован для нужд ФС */
#define DIR_ENTRIES 64U /* elements */

/* размер статической области обмена данными для нужд ФС */
/* как определить его - см. далее */
#define FS_DTA_SIZE 64U /* data transfer area size for filesystem driver */

/* размер кластера (блока) в байтах */
/* пространство на носителе выделяется с дискретностью размера блока */
#define FS_CLUSTER_SIZE 16U /* 16 bytes per cluster */

/* версия ФС */
#define FS_VERSION 0x00000001U

/* сколько файлов может быть открыто в один момент времени */
#define FS_CONCURRENT_FILES 01U /* number of files processed at the momnet */
```

#### Как хранятся данные.

**В начале** носителя (абс. смещение = 0) находится заголовок носителя,

```c
/* FAT header */
typedef struct {
	uint32_t FS_version;
	uint32_t DIR_CRC32;
	size_t FAT_ClusterTableSize;
	uint32_t dummy;		/* not used */
} FAT_Header_t;
```

не совсем корректно названный FAT_Header.

`FS_version` - версия ФС;

`DIR_CRC32` - контрольная сумма корневого (и единственного) каталога;

`FAT_ClusterTableSize` - размер в байтах таблицы размещения файлов.



**Далее** начинается корневой каталог. Он состоит из записей типа

```c
typedef struct __attribute__((packed)) {
	char FileName[MAX_FILENAME_LEN + 1U];
	fState_t FileStatus;		// 2 bytes
	uint16_t FileSize;
	size_t FileAddress;
	uint32_t FileCRC32;
} DIR_Entry_t;
```

где

`FileStatus`  - текущее состояние файла:

```c
typedef enum fState {
	FStateNoFile = 1, /* deleted file = free space */
	FStateClosed,
	FStateOpenedR,
	FStateOpenedW,
	FStateFAT /* only one and the first file is the FAT storage */
} fState_t;
```

Таблица размещения файлов хранится в первом файле на диске, который создается при форматировании и имеет специальное имя `$$FAT$$`, явно открыть, перезписать или удалить его нельзя.

`FileSize` - размер файла в байтах;

`FileAddress` - абсолютный адрес начала файла на носителе в байтах ( = смещение);

`FileCRC32` - контрольная сумма файла. Сейчас рассчитывается только для служебного файла `$$FAT$$` ради экономии времени.

**Далее** идут сами файлы, причем первым всегда идёт `$$FAT$$`.

#### Структура файла $$FAT$$.

`$$FAT$$` представляет собой битовый массив. Каждый бит представляет собой блок данных на диске (кластер). Если бит = 1, блок занят, иначе - свободен.

Размер массива в байтах  = (размер носителя - размер заголовка - размер корневого каталога) / 8.

Дефайн `FS_DTA_SIZE`, упомянутый вначале должен быть равным размеру $$FAT$$. При работе он считывается целиком!



Так как `$$FAT$$` это просто файл, то при форматировании занимаемое им место сразу помечается как занятое.

#### Присущие реализации ограничения.

- ФС не перераспределяет свободное место на диске (нет дефрагментации).
- Если в момент запроса на создание нового файла на носителе нет **непрерывного** свободного места для этого файла, он не будет создан. 
- Дописать данные в существующий файл можно только в пределах остатка места в последнем кластере файла.
- При создании файла с размером = 0, под него будет выделен 1 кластер. Соответственно, дописывать в файл можно будет только в пределах кластера.

### API.

Функции и возвращаемые значения было разработаны с учетом соместимости с FAT_FS.

Файл для пользователя представлен хэндлером:

```c
typedef struct {
	Media_Desc_p media;	/* descriptor of the media */
	DIR_Entry_t fileDir;
	size_t filePtr;
	mutex_t * pmutex;
} fHandle_t;
```

Вызывающая сторона должна позаботиться о выделении памяти под хэндлер.

`Media_Desc_p media` - указатель на описание носителя;

`DIR_Entry_t fileDir` - структура, представляющая собой вначале (при открытии или создании файла) копию записи из каталога. <u>**При перемещении файлового указателя инфа о новом положении сохраняется здесь, а не сразу на диске!**</u> Это сделано для ускорения работы.

**<u>Запись в каталоге на носителе обновляется только при закрытии файла!</u>**

Во избежании потери или затирания данных файл должен быть закрыт после использования. **<u>Также очень важно, чтобы файл был открыт в системе только один раз!</u>**

`size_t filePtr` - текущая позиция файлового указателя;

`mutex_t * pmutex` - указатель на мьютекс (некорректное название), который по сути - переменная , которая устанавливается в `1` при открытии файла и сбрасывается в `0` при закрытии. Размер массива этих переменных равен дефайну `FS_CONCURRENT_FILES`.

```c
/* Иничиализация. Должна быть вызвана первой. */
void InitFS(void);

/* Форматирование носителя */
ErrorStatus Format(const Media_Desc_t * const media);

/* Создание нового или открытие существующего файла */
FRESULT NewFile(fHandle_p file, const char *name, size_t size, fMode_t mode);

/* FAT_FS обертка над NewFile() */
FRESULT f_open(FIL* fp, const TCHAR* path, BYTE mode);				/* Open or create a file */

/* Закрытие файла */
FRESULT CloseFile(fHandle_p file);

/* FAT_FS обертка над CloseFile() */
FRESULT f_close (FIL* fp);							/* Close an open file object */

/* Удаление закрытого файла */
FRESULT DeleteFile(const Media_Desc_t *media, const char *name);

/* FAT_FS обертка над DeleteFile()  - не доделана !*/
FRESULT f_unlink (const TCHAR* path);						/* Delete an existing file or directory */

/* перемещение указателя fp в начало */
FRESULT f_rewind(FIL *fp);

/* перемещение указателя fp в ofs */
FRESULT f_lseek(FIL *fp, FSIZE_t ofs);

/* возвращает позицию указателя */
FSIZE_t f_tell (FIL* fp);

/* запись в файл */
FRESULT f_write (FIL* fp, void * const buff, UINT btw, UINT* bw);

/* чтение из файла */
FRESULT f_read(FIL *fp, void *buff, UINT btr, UINT *br);

/* check disk */
FRESULT f_checkFS(const Media_Desc_t *media);

/* возвращает текстовое представление переменной FRESULT*/
const char *FRESULT_String(FRESULT res);

```

### Многозадачность и reenterability.

Пользователь должен обеспечить две блокировки (средствами РТОС или самописными):

```c
/*
Мьютекс доступа к функциям файловой системы. Так как некоторые значения, необходимые для работы ФС, хранятся в static переменных, то мы должны обеспечить отсутствие множественного доступа к ним.
Мьютекс захватывается при вызове вышеперечисленных ф-ций и освобождается при выходе из них. Исключением является const char *FRESULT_String(FRESULT res);
*/
extern osMutexId FS_Mutex01Handle;

```

```c
/* Если мы используем для расчета CRC32 аппаратный блок МК, то нужен и этот мьютекс */
extern osMutexId CRC_MutexHandle;

```

При корректной работе этих мьютексов проверена работа под FreeRTOS на STM32F1, F3.

Так же абсолютно неправильно вызывать функции ФС, находясь в обработчике прерывания или в какой-нибудь критической ко времени секции. Внешние функции доступа к носителю могут непредсказуемо повлиять на время работы. В самих функциях ФС нет спинлоков и т.п. Если аппаратный CRC32 используется еще где-то вашем приложении, то нужно помнить, что он может быть занят в момент, когда он потребуется функциям файловой системы и она будет ждать его освобождения. **<u>Возможна ситуация взаимоблокировки!</u>**



### Тесты.

Репозиторий содержит тесты для ПК.

Попробовал применить, в том числе, и фаззинг-тестирование (fuzzing). 

`random_test.c` содержит рандомный тест, который выполняется 1 000 000 раз. Каждый раз случайно генерируется имя файла, его размер и требуемая операция. На основе этих данных алгоритм предсказывает ожидаемое поведение функций ФС и сравнивает его с фактическим результатом.



### Кэши.

Подумалось, что мы можем получить ускорение рабоы ФС в многозадачной системе, если применим буферизацию чтения/записи, т.е. добавим дисковый кэш! Кэш не входит в ФС, а реализуется как прослойка между ФС и функциями чтения/записи физ. носителя. Особенно полезным это будет для носителей, перезапись которых требует стирания страниц.